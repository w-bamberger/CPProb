/**
 * @file DiscreteRandomReferences.hpp
 * Collection of references to discrete random variables.
 *
 * @author Walter Bamberger
 *
 * @par License
 * Copyright (C) 2011 Walter Bamberger
 * @par
 * This file is part of CPProb.
 * @par
 * CPProb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version, with the
 * exceptions mentioned in the file LICENSE.txt.
 * @par
 * CPProb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * @par
 * You should have received a copy of the GNU Lesser General Public
 * License along with CPProb.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

#ifndef DISCRETERANDOMREFERENCES_H_
#define DISCRETERANDOMREFERENCES_H_

#include "DiscreteRandomVariable.hpp"
#include "Utils.hpp"
#include "cont/set.hpp"
#include <boost/iterator/indirect_iterator.hpp>

namespace cpprob
{

  class DiscreteRandomReferences
  {

    class IndirectNameLess
    {

    public:

      /**
       * Typedef for the concept of a binary function object. It gives the
       * type of the first argument of operator().
       */
      typedef DiscreteRandomVariable first_argument_type;

      /**
       * Typedef for the concept of a binary function object. It gives the
       * type of the second argument of operator().
       */
      typedef DiscreteRandomVariable second_argument_type;

      /**
       * Typedef for the concept of a binary function object. It gives the
       * type of the result of operator().
       */
      typedef bool result_type;

      bool
      operator()(const DiscreteRandomVariable* var1,
          const DiscreteRandomVariable* var2) const
      {
        cpprob_check_debug(
            var1->characteristics_ != DiscreteRandomVariable::characteristics_table_.end() && var2->characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
            "DiscreteRandomReferences: Cannot compare a variable that is not associated with a set of observations.");
        return var1->characteristics_->first < var2->characteristics_->first;
      }

    };

    typedef cont::set<const DiscreteRandomVariable*, IndirectNameLess> Variables;

  public:

    typedef boost::indirect_iterator<Variables::const_iterator> const_iterator;
    typedef boost::indirect_iterator<Variables::iterator> iterator;
    typedef Variables::size_type size_type;
    class SubRange;
    class SubRangeEnumerator;

    DiscreteRandomReferences()
        : characteristics_(
            DiscreteRandomVariable::characteristics_table_.end()), references_()
    {
    }

    template<class Iterator>
      DiscreteRandomReferences(Iterator begin, Iterator end)
          : characteristics_(
              DiscreteRandomVariable::characteristics_table_.end()), references_(
              begin, end)
      {
      }

    // Use the implicit destructor, so the implicit copy and move operations
    // are generated by the compiler.

    iterator
    begin()
    {
      return iterator(references_.begin());
    }

    const_iterator
    begin() const
    {
      return const_iterator(references_.begin());
    }

    void
    clear()
    {
      references_.clear();
    }

    size_type
    count(const DiscreteRandomVariable& var) const
    {
      DiscreteRandomVariable* const p =
          &const_cast<DiscreteRandomVariable&>(var);
      return references_.count(p);
    }

    iterator
    end()
    {
      return iterator(references_.end());
    }

    const_iterator
    end() const
    {
      return const_iterator(references_.end());
    }

    std::pair<iterator, bool>
    insert(const DiscreteRandomVariable& new_reference)
    {
      characteristics_ = DiscreteRandomVariable::characteristics_table_.end();
      return references_.insert(&new_reference);
    }

    DiscreteRandomVariable
    joint_value() const;

    std::size_t
    size() const
    {
      return references_.size();
    }

    SubRange
    sub_range(const DiscreteRandomVariable& var) const;

  private:

    mutable DiscreteRandomVariable::CharacteristicsTable::iterator characteristics_;
    Variables references_;

    void
    set_up_characteristics() const;

  };

  class DiscreteRandomReferences::SubRangeEnumerator
  {

  public:

    SubRangeEnumerator()
        : characteristics_(
            DiscreteRandomVariable::characteristics_table_.end()), step_size_(
            0), value_(0)
    {
    }

    DiscreteRandomVariable
    joint_value() const
    {
      cpprob_check_debug(
          characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
          "DiscreteRandomReferences: Cannot compute the joint value of a singular sub range enumerator.");

      return DiscreteRandomVariable(characteristics_, value_);
    }

    SubRangeEnumerator&
    operator++()
    {
      cpprob_check_debug(
          characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
          "DiscreteRandomReferences: Cannot increment a singular sub range enumerator.");
      // The end value may be somewhere behind size_. But the previous value
      // must be lower than size_.
      cpprob_check_debug(
          value_ < characteristics_->second.size_,
          "DiscreteRandomReferences: Cannot increment a sub range enumerator past the end (value: " << value_ << ", step_size: " << step_size_ << ", max value: " << characteristics_->second.size_ << ").");

      value_ += step_size_;
      return *this;
    }

    SubRangeEnumerator
    operator++(int)
    {
      cpprob_check_debug(
          characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
          "DiscreteRandomReferences: Cannot increment a singular sub range enumerator.");
      // The end value may be somewhere behind size_. But the previous value
      // must be lower than size_.
      cpprob_check_debug(
          value_ < characteristics_->second.size_,
          "DiscreteRandomReferences: Cannot increment a sub range enumerator past the end (value: " << value_ << ", step_size: " << step_size_ << ", max value: " << characteristics_->second.size_ << ").");

      auto tmp = *this;
      value_ += step_size_;
      return tmp;
    }

    SubRangeEnumerator&
    operator--()
    {
      cpprob_check_debug(
          characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
          "DiscreteRandomReferences: Cannot decrement a singular sub range enumerator.");
      cpprob_check_debug(
          value_ >= step_size_,
          "DiscreteRandomReferences: Cannot decrement a sub range enumerator below the begin (value: " << value_ << ", step_size: " << step_size_ << ").");

      value_ -= step_size_;
      return *this;
    }

    SubRangeEnumerator
    operator--(int)
    {
      cpprob_check_debug(
          characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
          "DiscreteRandomReferences: Cannot decrement a singular sub range enumerator.");
      cpprob_check_debug(
          value_ >= step_size_,
          "DiscreteRandomReferences: Cannot decrement a sub range enumerator below the begin (value: " << value_ << ", step_size: " << step_size_ << ").");

      auto tmp = *this;
      value_ -= step_size_;
      return tmp;
    }

  private:

    typedef DiscreteRandomVariable::CharacteristicsTable::iterator CharacteristicsIterator;
    friend class SubRange;

    CharacteristicsIterator characteristics_;
    std::size_t step_size_;
    std::size_t value_;

    SubRangeEnumerator(CharacteristicsIterator characteristics,
        std::size_t step_size, std::size_t value)
        : characteristics_(characteristics), step_size_(step_size), value_(
            value)
    {
      cpprob_check_debug(
          characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
          "DiscreteRandomReferences: A sub range enumerator has been initialized with an invalid characteristics entry.");
      cpprob_check_debug(step_size_ != 0,
          "DiscreteRandomReferences: The step size 0 is invalid.");
      cpprob_check_debug(
          value_ <= (characteristics_->second.size_ - 1 + step_size_),
          "DiscreteRandomReferences: The value (" << value_ << ") must be within the value range of the random variable (" << characteristics_->second.size_ << ").");
    }

  };

  class DiscreteRandomReferences::SubRange
  {

  public:

    typedef DiscreteRandomReferences::SubRangeEnumerator iterator;
    typedef DiscreteRandomReferences::SubRangeEnumerator const_iterator;

    iterator
    begin() const
    {
      return SubRangeEnumerator(characteristics_, step_size_, value_begin_);
    }

    iterator
    end() const
    {
      return SubRangeEnumerator(characteristics_, step_size_, value_end_);
    }

    std::size_t
    size() const
    {
      return (value_end_ - value_begin_) / step_size_;
    }

  private:

    typedef DiscreteRandomVariable::CharacteristicsTable::iterator CharacteristicsIterator;
    friend class DiscreteRandomReferences;

    CharacteristicsIterator characteristics_;
    std::size_t step_size_;
    std::size_t value_begin_;
    std::size_t value_end_;

    SubRange(CharacteristicsIterator characteristics, std::size_t step_size,
        std::size_t value_begin, std::size_t value_end)
        : characteristics_(characteristics), step_size_(step_size), value_begin_(
            value_begin), value_end_(value_end)
    {
      cpprob_check_debug(
          characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
          "DiscreteRandomReferences: A sub range has been initialized with an invalid characteristics entry.");
      cpprob_check_debug(step_size_ != 0,
          "DiscreteRandomReferences: The step size 0 is invalid.");
      cpprob_check_debug(
          value_end_ <= (characteristics_->second.size_ - 1 + step_size_),
          "DiscreteRandomReferences: The end value (" << value_end_ << ") must be within the value range of the random variable (" << characteristics_->second.size_ << ").");
      cpprob_check_debug(
          value_begin_ <= value_end_,
          "DiscreteRandomReferences: The start value (" << value_begin_ << ") must be smaller than the end value (" << value_end_ << ").");
    }

  };

} /* namespace cpprob */

#endif /* DISCRETERANDOMREFERENCES_H_ */
