/**
 * @file DiscreteRandomReferences.hpp
 * Collection of references to discrete random variables.
 *
 * @author Walter Bamberger
 *
 * @par License
 * Copyright (C) 2011 Walter Bamberger
 * @par
 * This file is part of CPProb.
 * @par
 * CPProb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version, with the
 * exceptions mentioned in the file LICENSE.txt.
 * @par
 * CPProb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * @par
 * You should have received a copy of the GNU Lesser General Public
 * License along with CPProb.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

#ifndef DISCRETERANDOMREFERENCES_H_
#define DISCRETERANDOMREFERENCES_H_

#include "DiscreteRandomVariable.hpp"
#include "Utils.hpp"
#include "cont/set.hpp"
#include <boost/iterator/indirect_iterator.hpp>

namespace cpprob
{

  class DiscreteRandomReferences
  {

    class IndirectNameLess
    {

    public:

      /**
       * Typedef for the concept of a binary function object. It gives the
       * type of the first argument of operator().
       */
      typedef DiscreteRandomVariable first_argument_type;

      /**
       * Typedef for the concept of a binary function object. It gives the
       * type of the second argument of operator().
       */
      typedef DiscreteRandomVariable second_argument_type;

      /**
       * Typedef for the concept of a binary function object. It gives the
       * type of the result of operator().
       */
      typedef bool result_type;

      bool
      operator()(const DiscreteRandomVariable* var1,
          const DiscreteRandomVariable* var2) const
      {
        cpprob_check_debug(
            var1->characteristics_ != DiscreteRandomVariable::characteristics_table_.end() && var2->characteristics_ != DiscreteRandomVariable::characteristics_table_.end(),
            "DiscreteRandomReferences: Cannot compare a variable that is not associated with a set of observations.");
        return var1->characteristics_->first < var2->characteristics_->first;
      }

    };

    typedef cont::set<const DiscreteRandomVariable*, IndirectNameLess> Variables;

  public:

    typedef boost::indirect_iterator<Variables::const_iterator> const_iterator;
    typedef boost::indirect_iterator<Variables::iterator> iterator;
    typedef Variables::size_type size_type;

    DiscreteRandomReferences()
        : characteristics_(
            DiscreteRandomVariable::characteristics_table_.end()), references_()
    {
    }

    template<class Iterator>
      DiscreteRandomReferences(Iterator begin, Iterator end)
          : characteristics_(
              DiscreteRandomVariable::characteristics_table_.end()), references_(
              begin, end)
      {
      }

    // Use the implicit destructor, so the implicit copy and move operations
    // are generated by the compiler.

    iterator
    begin()
    {
      return iterator(references_.begin());
    }

    const_iterator
    begin() const
    {
      return const_iterator(references_.begin());
    }

    void
    clear()
    {
      references_.clear();
    }

    size_type
    count(const DiscreteRandomVariable& var) const
    {
      DiscreteRandomVariable* const p =
          &const_cast<DiscreteRandomVariable&>(var);
      return references_.count(p);
    }

    iterator
    end()
    {
      return iterator(references_.end());
    }

    const_iterator
    end() const
    {
      return const_iterator(references_.end());
    }

    std::pair<iterator, bool>
    insert(const DiscreteRandomVariable& new_reference)
    {
      characteristics_ = DiscreteRandomVariable::characteristics_table_.end();
      return references_.insert(&new_reference);
    }

    DiscreteRandomVariable
    joint_value() const;

    std::size_t
    size() const
    {
      return references_.size();
    }

  private:

    mutable DiscreteRandomVariable::CharacteristicsTable::iterator characteristics_;
    Variables references_;

    void
    set_up_characteristics() const;

  };

} /* namespace cpprob */

#endif /* DISCRETERANDOMREFERENCES_H_ */
